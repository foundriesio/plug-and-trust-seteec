
import textwrap

FILE_HEADER=r"""
 *
/* Copyright 2019,2020 NXP
 * SPDX-License-Identifier: Apache-2.0
 */

/** @file */

#ifndef se05x_perso_API_H
#define se05x_perso_API_H

#include "se05x_tlv.h"

smStatus_t Se05x_API_Perso_SelectApplet(pSe05xSession_t session_ctx);

#define SE05X_API_PERSO_U8_CREATE_API_SET(P1P2) \
    smStatus_t Se05x_API_Perso_Set_##P1P2(pSe05xSession_t session_ctx, uint8_t in_value)

#define SE05X_API_PERSO_U8_CREATE_API_GET(P1P2) \
    smStatus_t Se05x_API_Perso_Get_##P1P2(pSe05xSession_t session_ctx, uint8_t *out_value)

#define SE05X_API_PERSO_U16_CREATE_API_SET(P1P2) \
    smStatus_t Se05x_API_Perso_Set_##P1P2(pSe05xSession_t session_ctx, uint16_t in_value)

#define SE05X_API_PERSO_U16_CREATE_API_GET(P1P2) \
    smStatus_t Se05x_API_Perso_Get_##P1P2(pSe05xSession_t session_ctx, uint16_t *out_value)

#define SE05X_API_PERSO_AU8_CREATE_API_SET(P1P2) \
    smStatus_t Se05x_API_Perso_Set_##P1P2(pSe05xSession_t session_ctx, const uint8_t *in_buf, size_t in_bufLen)

#define SE05X_API_PERSO_AU8_CREATE_API_GET(P1P2) \
    smStatus_t Se05x_API_Perso_Get_##P1P2(pSe05xSession_t session_ctx, uint8_t *out_buf, size_t *out_bufLen)

"""


FILE_FOOTER = r"""
#endif /* se05x_perso_API_h */
"""


FILE_FOOTER = r"""
#endif /* se05x_perso_API_h */
"""

ALL_APIs = [
# "TCL_SAK_COMPLETE",
# "TCL_L3_ACTIVATION_CONTROL",
# "TCL_ATS_IF",
"TCL_ATS_CURRENT_HISTLEN_CHARS",
"TCL_ATS_HISTCHARS",
# "TCL_ATQA_MSB",
# "TCL_ATQA_LSB",
"7816_ATR_COLD_HIST_LEN_CHARS",
"7816_ATR_COLD_HIST",
"7816_ATR_WARM_HIST_LEN_CHARS",
"7816_ATR_WARM_HIST",
"I2C_SLAVE_ADDRESS",
"I2C_PARAMS",
"ATR_I2C_IF_BYTES",
# "OS_TIMER_INIT",
# "OS_TIMER_UPDATE_THRESHOLD",
# "GP_CONFIG",
"PRSWL_ENABLED",
"FIPS_MODE_ENABLED",
"CIP_I2C_IF_BYTES",
"ATR_CIP_I2C_HIST_CHARS",
"DELETE_OS_MODULE",
]


APIS_DESCRIPTION = {
"TCL_SAK_COMPLETE"  : ( "1-byte value: SAK in case of incomplete UID, only used for CIU.",  ),
"TCL_L3_ACTIVATION_CONTROL"    : ( "1-byte value: L3 Activation Control Parameter.",
        "0x00: Use Random UID (generated by the OS).",
        "0x04: Use UID stored in Security Row of P71.(even if ATQA select selects a different source for ATQA).",
        "0x08: Use UID stored in Security Row of P71 to calculate a single size fixed non-unique ID. All other bits are RFU",   ),
"TCL_ATS_IF_CHARS"    : ( "Length of TCL_ATS_IF", ),
"TCL_ATS_IF"    : ( "Byte array (max 5 bytes): TCL Interface Bytes used for CIU. This are the first bytes in the ATS before the Historical Characters. (T0, [TA1], [TB1], [TC1]) The first byte defines the length (excl. length byte). The IF-Length and T0 are always present, all others are optional and depend on the content of T0.", ),
"TCL_ATS_CURRENT_HISTLEN_CHARS" : ( "Length(1 bytes): Defines the actually used length of the historical characters in configuration item TCL_ATS_HISTCHARS",   ),
"TCL_ATS_HISTCHARS" : ( "Byte array (max 20 bytes): Historical characters used for T=CL.",  ),
"TCL_ATQA_MSB"  : ( "1-byte value: ATQA MSB byte only used for CIU",    ),
"TCL_ATQA_LSB"  : ( "1-byte value: ATQA LSB byte only used for CIU",    ),
"7816_ATR_COLD_HIST_LEN_CHARS" : ( "Length(1 bytes):",
        "Histchar length for Cold Reset ISO7816 protocol.", ),
"7816_ATR_COLD_HIST"   : ( "Byte array (max 15 bytes): Histchars for Cold Reset ISO7816 protocol ",    ),
"7816_ATR_WARM_HIST_LEN_CHARS"  : ( "Length(1 bytes):",
        "Histchar length for Warm Reset ISO7816 protocol",  ),
"7816_ATR_WARM_HIST"   : ( "Byte array (max 15 bytes): Histchars for Warm Reset ISO7816 protocol. ",   ),
"I2C_SLAVE_ADDRESS" : ( "1-byte value: I2C slave address of product.",  ),
"I2C_PARAMS"    : ( "1-byte value: Bitmask to configure the I2C protocol Each bit of the bitmask switches the feature:",
        "0 = Off, feature disabled",
        "1 = On, feature enabled",
        "bit 0 : Slave clock stretching (0=clock stretching disabled, 1=clock stretching enabled)",
        "bit 1 : Enable power saving mode after sending End of APDU Session response (0=power save mode disabled, 1=power save mode enabled)",
        "bit 2 : Select flavour of T1I2C protocol (0=NXP flavour, 1=GP flavour)",
        "bit 3 : Select the T1I2C protocol communication mode (0=Semi Non-Blocking Communication, 1=Blocking Communication)",
        "bit 7-4: Interface detection delay time during start up (multiplied by 100 us)",   ),
"ATR_I2C_IF_BYTES"  : ( "Byte array: ATR definition for I2C interface. ",  ),
"OS_TIMER_INIT" : ( "2-byte value: values to initialize system timer A: b15 RFU",
        "b14 Enable Timer on Contactless Interface",
        "b13 Enable Timer on Contact Interface",
        "b12 Enable Timer on I2C",
        "b11:10 IRQ_LVL:Interrupt acceptance level. 00:Off, 01:Low, 10:medium, 11:High",
        "b9 IRQ_WUP: If set then a transition from 0x0001 to 0x0000 or to the reload value generates a wakeup request.",
        "b8 IRQ Relevance selector 0: Generic 1: Critical",
        "b4:b7 DIV: Predivider for the timer ", "- It decrements upon each DIV+1-th period of the 12MHz reference clock.",
        "b3 Mode, 0:timer stops when expired, 1:timer is reloaded and continues/",
        "b2 RFU ",
        "b1 RFU ",
        "b0 RFU",   ),
"OS_TIMER_UPDATE_THRESHOLD" : ( "2-byte value: The counter timer interval between interrupts. The resolution is defined by the chosen divider value in NXCONF_OS_TIMER_INIT.",  ),
"GP_CONFIG"    : ( "2-byte value: Bit mask stating GlobalPlatform features supported",  ),
"PRSWL_ENABLED" : ( "1-byte value: Configuration to enable/disable periodic Static Wear Leveling", "0x00: Periodic static wear leveling is disabled. Enable periodic Static Wear Leveling: ",
        "Bit 0...6: a counter of APDUs after which the static wearlevelling is triggered. if 0, static wearlevelling is disabled and will only be executed during startup. Any other value (range 1 ... 127) will count the incoming APDUs and trigger the wear levelling when this counter is reached ",
        "Bit 7: steers time dependent behavior when set to 1, Static Wearlevelling will also happen every 3.5 hours (about) when the active interface is T1I2C. It will not have any effect on TCL or CT interface.",  ),
"CIP_I2C_IF_BYTES"  : ( "Byte array: ATR definition for I2C interface. ",  ),
"ATR_CIP_I2C_HIST_CHARS"    : ( "Byte array (max 25 bytes): ATR Historical Character definition for I2C interface. ",  ),
"FIPS_MODE_ENABLED" : ( "1-byte value: 0x00 = FIPS disabled; 0x01 = FIPS enabled.", ),
"DELETE_OS_MODULE"  : ( "Byte array: AID of module to be deleted .", )

}


APIS_SIZE = {
    "7816_ATR_COLD_HIST" : "AU8",
    "7816_ATR_COLD_HIST_LEN_CHARS" : "U8",
    "7816_ATR_WARM_HIST" : "AU8",
    "7816_ATR_WARM_HIST_LEN_CHARS" : "U8",
    "ATR_CIP_I2C_HIST_CHARS" : "AU8",
    "ATR_I2C_IF_BYTES" : "AU8",
    "CIP_I2C_IF_BYTES" : "AU8",
    "DELETE_OS_MODULE" : "AU8",
    "FIPS_MODE_ENABLED" : "U8",
    "GP_CONFIG" : "U16",
    "I2C_PARAMS" : "U8",
    "I2C_SLAVE_ADDRESS" : "U8",
    "OS_TIMER_INIT" : "U16",
    "OS_TIMER_UPDATE_THRESHOLD" : "U16",
    "PRSWL_ENABLED" : "U8",
    "TCL_ATQA_LSB" : "U8",
    "TCL_ATQA_MSB" : "U8",
    "TCL_ATS_CURRENT_HISTLEN_CHARS" : "U8",
    "TCL_ATS_HISTCHARS" : "AU8",
    "TCL_ATS_IF" : "AU8",
    "TCL_L3_ACTIVATION_CONTROL" : "U8",
    "TCL_SAK_COMPLETE" : "U8",
    "TCL_ATS_IF_CHARS" : "U8",
}


APIS_RW = {
    "7816_ATR_COLD_HIST" : "rw",
    "7816_ATR_COLD_HIST_LEN_CHARS" : "rw",
    "7816_ATR_WARM_HIST" : "rw",
    "7816_ATR_WARM_HIST_LEN_CHARS" : "rw",
    "ATR_CIP_I2C_HIST_CHARS" : "rw",
    "ATR_I2C_IF_BYTES" : "rw",
    "CIP_I2C_IF_BYTES" : "rw",
    "TCL_ATS_IF_CHARS" : "r",
    "DELETE_OS_MODULE" : "w",
    "FIPS_MODE_ENABLED" : "r",
    "GP_CONFIG" : "rw",
    "I2C_PARAMS" : "rw",
    "I2C_SLAVE_ADDRESS" : "rw",
    "OS_TIMER_INIT" : "rw",
    "OS_TIMER_UPDATE_THRESHOLD" : "rw",
    "PRSWL_ENABLED" : "rw",
    "TCL_ATQA_LSB" : "rw",
    "TCL_ATQA_MSB" : "rw",
    "TCL_ATS_CURRENT_HISTLEN_CHARS" : "rw",
    "TCL_ATS_HISTCHARS" : "rw",
    "TCL_ATS_IF" : "rw",
    "TCL_L3_ACTIVATION_CONTROL" : "rw",
    "TCL_SAK_COMPLETE" : "rw",
}

DELETE_MODULES_LIST = (
    # ("com/nxp/id/jcop/ecc",
    #     "D276000085304A434F504D4F4401",
    #         "Basic Elliptic Curve Cryptography."),
    ("com/nxp/id/jcop/iot_extended",
        "D276000085304A434F504D4F440B",
            "Extension to Elliptic Curve Cryptography."),
    ("com/nxp/id/jcop/iot_base",
        "D276000085304A434F504D4F440A",
            "Collection of crypto algorithms often used in IoT devices."),
    ("com/nxp/id/jcopx/egovaccelerators",
        "D276000085304A434F506E",
            "Secure Messaging Accelerators for eGovernment applications and modular arithmetic math API."),
    # ("com/nxp/id/jcopx/securebox",
    #     "D276000085304A434F505F",
    #         "Platform for custom native accelerators. Accelerator code needs to be provided to NXP."),
    ("com/nxp/id/jcop/rsakeygen",
        "D276000085304A434F504D4F4400",
            "On chip generation of RSA keys."),
    # ("com/nxp/id/jcop/config_module",
    #     "D276000085304A434F504D4F4406",
    #         "Configuration of the JCOP OS."),
    # ("com/nxp/id/jcopx/oscca",
    #     "D276000085304A434F504D4F440D",
    #         "Functional implementation of OSCCA ciphers."),
    # ("com/nxp/id/jcop/fips",
    #     "D276000085304A434F504D4F4407",
    #         "FIPS 140-2 Selftests"),
)


def writeTheAPI(o, api, desc, size, rw):
    if "r" in rw:
        writeTheAPI_r(o, api, desc, size)
    if "w" in rw:
        writeTheAPI_w(o, api, desc, size)

def writeTheAPI_r_u8(o, api):
    o.write("""smStatus_t Se05x_API_Perso_Get_%s(
        pSe05xSession_t session_ctx,
        uint8_t *out_value);\n\n"""%(api,))

def writeTheAPI_w_u8(o, api):
    o.write("""smStatus_t Se05x_API_Perso_Set_%s(
        pSe05xSession_t session_ctx,
        uint8_t in_value);\n\n"""%(api,))


def writeTheAPI_r_au8(o, api):
        o.write("""smStatus_t Se05x_API_Perso_Get_%s(
        pSe05xSession_t session_ctx,
        uint8_t *out_buf,
        size_t *out_bufLen);\n\n"""%(api,))

def writeTheAPI_w_au8(o, api):
    o.write("""smStatus_t Se05x_API_Perso_Set_%s(
        pSe05xSession_t session_ctx,
        const uint8_t *in_buf,
        size_t in_bufLen);\n\n"""%(api,))

def writeTheAPI_r_u16(o, api):
    o.write("""smStatus_t Se05x_API_Perso_Get_%s(
        pSe05xSession_t session_ctx,
        uint16_t *out_value);\n\n"""%(api,))

def writeTheAPI_w_u16(o, api):
    o.write("""smStatus_t Se05x_API_Perso_Set_%s(
        pSe05xSession_t session_ctx,
        uint16_t in_value);\n\n"""%(api,))

writeTheAPI_r_size = {
    "U8" : writeTheAPI_r_u8,
    "AU8" : writeTheAPI_r_au8,
    "U16" : writeTheAPI_r_u16,
}
writeTheAPI_w_size = {
    "U8" : writeTheAPI_w_u8,
    "AU8" : writeTheAPI_w_au8,
    "U16" : writeTheAPI_w_u16,
}
def writeTheAPI_r(o, api, desc, size):
    o.write("/**\n * Get value of %s\n"%api)
    writeSummary(o, desc)
    writeTheAPI_r_size[size](o, api)


def writeTheAPI_w(o, api, desc, size):
    o.write("/**\n * Configuration of %s\n"%api)
    writeSummary(o, desc)
    writeTheAPI_w_size[size](o, api)

def writeSummary(o, desc):
    if len(desc) == 1:
        tw = textwrap.wrap(desc[0])
        o.write(" *\n")
        for e in tw:
            o.write(" * %s\n"%e)
    else:
        o.write(" * %s\n"%desc[0])
        o.write(" *\n")
        for l in desc[1:]:
            tw = textwrap.wrap(l)
            o.write(" *\n")
            if len(tw) == 1:
                o.write(" * - %s\n"%tw[0])
            else:
                o.write(" * - %s\n"%tw[0])
                for e in tw[1:]:
                    o.write(" *   %s\n"%e)
    o.write(" */\n")

def writeDeletables(o):
    for (path_id, hex_id, desc) in DELETE_MODULES_LIST:
        o.write("\n")
        o.write("/** Deletable module %s\n"%(path_id))
        o.write(" *\n")
        o.write(" * ID = %s\n"%(hex_id))
        o.write(" *\n")
        o.write(" * %s */\n"%(desc))
        o.write("#define %s {\\\n    "%(path_id.upper()\
            .replace("/","_")\
            .replace("COM_NXP_ID_JCOP","SE05X_API_PERSO_MOD")
            ))
        for i in range(len(hex_id)//2):
            o.write("0x%s"%(hex_id[i*2+0]))
            o.write("%s, "%(hex_id[i*2+1]))
        o.write("}\n")


def generateHFile(o):
    o.write(FILE_HEADER)
    # o.write(MISC_DEFINES)
    # o.write(API_CALLS)
    writeDeletables(o)
    for api in ALL_APIs:
        desc = APIS_DESCRIPTION[api]
        size = APIS_SIZE[api]
        rw = APIS_RW[api]
        writeTheAPI(o, api, desc, size, rw)
    o.write(FILE_FOOTER)

def main():
    with open("se05x_perso_api.h","w") as o:
        generateHFile(o)


if __name__ == '__main__':
    main()
